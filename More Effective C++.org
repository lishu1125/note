* *条款1：仔细区别pointers和references*
- 没有null reference
#+BEGIN_SRC c++
char* pc = 0; //将pointer设定为null
char& pc = *pc //让reference代表null pointer的解引用
#+END_SRC
这是有害行为，其结果不可预期（C++对此没有定义）
- “没有所谓的null reference”这个事实意味使用references可能会比使用pointers更富有效率。这是因为使用reference之前不需要
测其有效性
* *条款2：最好使用c++转型操作符*
| static\_cast      | 基本上拥有与c旧式转型相同的威力与意义，以及相同的限制                                                              |
| const\_cast       | 改变表达式中的常量行（constness）或变易性（volatileness）。最常见用途是将某一个对象的常量性去除                    |
| dynamic\_cast     | 将指向base class的pointers或references转型为指向derived（或sibling base）class的pointers或references，并得         |
|                   | 知转型是否成功。如果转型失败，会以一个null指针（当转型对象是指针）或一个exception（当转型对象是reference）表现出来 |
| reinterpret\_cast | 最常用用途是转换“函数指针”类型                                                                                   |
- 利用宏仿真
#+BEGIN_SRC c++
#define static_cast(TYPE, EXPR) ((TYPE)(EXPR))
#define const_cast(TYPE, EXPR) ((TYPE)(EXPR))
#define reinterpret_cast(TYPE, EXPR) ((TYPE)(EXPR))
#+END_SRC
* *条款3：绝对不要以多态（polymorphically）方式处理数组*
- 多态（polymorphism）和指针算术不能混用
* *条款4：非必要不提供default constructor*
- 添加无意义的default constructor会影响classes的效率
* *条款5：对定制的“类型转换函数”保持警觉*
- 所谓隐式类型转换操作符：关键词operator之后加上一个类型名称，不能为此函数指定返回值类型
#+BEGIN_SRC c++
class Rational {
public:
    ...
    operator double() const;
};
#+END_SRC
这个函数会在以下情况被自动调用：
#+BEGIN_SRC c++
Rational r(1, 2); //r的值是1/2
double d = 0.5 * r; //将r转换为double，然后执行乘法运算
#+END_SRC
解决办法是以功能对等的另一个函数取代类型转换操作符
#+BEGIN_SRC c++
class Rational {
public:
    ...
    double asDouble() const; //将Rational转换为double
};
#+END_SRC
如此的member function必须被明确调用
#+BEGIN_SRC c++
Rational r(1, 2);
cout << r; //错误！Rationals没有operator double()
cout << r.asDouble(); //可！以double形式输出r
#+END_SRC
- 通过单自变量constructs完成的隐式转换，较难消除
#+BEGIN_SRC c++
template<class T>
class Array {
public:
    Array(int lowBound, int highBound);
    Array(int size);

    T& operator[](int index);
    ...
};
#+END_SRC
考虑一个用来对Array<int>对象进行比较动作的函数，以及一小段代码：
#+BEGIN_SRC c++
bool operator==(const Array<int>& lhs,
                const Array<int>& rhs);
Array<int> a(10);
Array<int> b(10);
...
for (int i=0; i<10; ++i) {
    if(a == b[i]) { //哎哟！"a"应该是"a[i]"才对
        // do something;
    }
    else {
        // do something;
    }
}
#+END_SRC
编译器产生类似这样的代码：
#+BEGIN_SRC c++
for (int i=0; i<10; ++i)
    if(a == static_cast<Array<int> >(b[i]))) ...
#+END_SRC
